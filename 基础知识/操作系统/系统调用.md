## 系统调用

​		操作系统是管理计算机硬件的一层软件系统,  系统调用是操作系统向外提供的使用操作系统的入口.  另外,  系统调用也是通向操作系统内核的窗口,  很多关乎内核模块的理解都要从这扇大门走进去.

#### 系统调用是为了解决什么问题

​        为什么要提供系统调用?  在操作系统内存管理中,  会将内存分为内核段和用户段,  还有另外一种说法是内核态和用户态,  用户态中的程序不能随意访问内核态中的数据或者程序,  只能通过系统调用来访问.  这样做的好处是能够保护操作系统, 并提供权限控制,  那些敏感数据或者指令可以存放在内核段中,  这样就不会被随意访问或者修改,  以免造成损失.

​		另外系统调用给上层用户提供了“统一接口”,  方便用户使用.

#### 系统调用的实现机理

​       系统调用能够让用户态的程序访问内核态中的内容,  这跟内存管理有关,  再结合内存特权级,  就能实现权限控制.  操作系统会对内存进行划分,  操作系统所在的内存区域为内核态,  并且这段内存的特权级设置的很高,  用户程序所在的区域的特权级设的低一些.  这样在用户程序访问内核段时,  进行特权检查,  如果要访问的内存区域比自己的特权级别高,  CPU会拒绝执行.

​		CPU提供了一种被称为特权环的机制来实现这个特权级检查.  很多指令在执行时都需要进行这样的特权级检查,  为了提高执行效率,  应该用计算机硬件即CPU电路来实现这个权限检查,  而不是用软件来实现.  更具体地说,  CPU在执行指令时如果发现需要进行特权级检查,  例如要进行跨段的jmp跳转,  就会取出两个重要数值:  当前特权级(current privilege level, CPL)和描述符特权级(descriptor privilege leven, 或destination privilege level, DPL)进行比对,  只有特权级满足要求,  才允许这条指令被解释执行,  否则出错.

​		当前特权级(CPL)用来表示当前执行指令的特权级.  CPL是存放在CS寄存器中的一个两位二进制数,  之所以定义CPL为两位二进制数,  是因为这里讨论的CPU只有4个保护环,  其中环0特权级最高,  操作系统内核在这一层上执行, 环3特权级最低,  应用程序在这一层上执行.  为什么要将CPL放置在CS寄存器中呢?  特权级实际上描述的是一块内存,  而在计算机中用来描述一块内存区域的概念就是段.  段是由一个段寄存器中来表示的,  所以CPL就存放在段寄存器中.  另外,  当前指令由CS:IP指示,  所以将CPL放在CS中非常合适.

​		描述符特权级(DPL)用来表示一个目标段的特权级.  DPL是一个存放在描述符表(GDT, IDT)中的两位二进制数.  特权检查发生在访问、跳转到一个目标内存区域之时,  在操作系统中一块内存区域就是一个段,  而用来描述一个段的信息就放在对应的段表相中,  也称之为段描述符中.  因此将目标内存区域的特权级信息放在目标段的描述符中也就顺理成章了.　

####  系统调用与int 0x80

​		操作系统应该给上层应用留一个进入操作系统入口,  中断就是这个入口.  操作系统给上层应用提供了0x80号中断,  应用程序可以通过”int 0x80“指令进入对应的中断处理程序,  用这个唯一的入口进入内核.  操作系统利用这个中断处理程序来实施各种安全检查,  让上层应用只能按照操作系统规定的格式来使用操作系统.

​		在执行“int 0x80”指令也要发生前往目标内存区域的跳转,  此时也需要执行CPL和DPL的特权检查,  所以操作系统在初始化0x80中断处理时特意将其DPL设置为3,  这样int0x80虽然位于内核段,  但是也可以被用户段的程序访问到.