## 进程同步——让多个进程的推进合理有序

​		多个进程在操作系统中并发向前推进,  这是操作系统的核心视图.  多个进程在并发执行过程中,  并不一定完全独立,  会相互独立,  会相互依赖,  在操作系统中如何实现这些以来关系,  这就是本章要解决的问题.

### 进程同步问题与睡眠/唤醒

​		每个进程都有自己要完成的工作,  即要执行的程序.  因为多个进程之间存在依赖关系,  所以进程不能一直执行自己的工作,  需要在适当的时候产看其他进程的工作情况,  然后根据查看结果来决定自己是否继续工作.

​		例如,   在一辆公交汽车上,  “司机进程”和“售票员进程”分别要完成如下工作.  如果司机只关注自己的工作,  随意时间启动车辆,  那么就有可能在某个乘客刚下车或者刚上车就启动车辆;  如果售票员进程也是埋头关注执行自己的程序,  随意的打开车门,  那么很有可能在汽车行驶的过程中就打开车门.

```java
//司机进程
while(true) {
		启动车辆;
		驾驶车辆;
		停靠车辆;
}
```

```java
//售票员进程
while(true) {
		打开车门;
		售票;
		关闭车门
}
```

​		正确的工作模式是: 车辆停靠以后,  司机一直等待,  并不执行后续动作——启动车辆.  直到售票员在完成售票并且关闭车门以后,  司机进程才被唤醒,  继续启动车辆、驾驶车辆.  当然对于售票员也存在这样的等待和唤醒.  由此可见,  正是这些等待和唤醒实现了进程之间的相互依赖.

​		这就是进程同步的基本结构:  一个进程在需要同步的地方停下来等待依赖进程,  当发现依赖进程完成了和同步对应的工作以后,  这个进程再继续向前执行.  顾名思义,  同步就是让步调一致,  当司机进程再执行到某个需要同步的地方时,  要停下来等待,  知道售票员完成某个被司机依赖的动作.

​		因此可以给进程同一个一个描述性定义,  进程同步就是通过对进程走走停停(等待和唤醒)的控制来让多个进程步调一致,  合理有序地向前推进,  完成依赖、相互合作.

### 从信号到信号量

#### 利用信号解决同步问题

​		现在,  将操作系统、进程同步和信号结合在一起就会形成这样的故事:  在需要同步的位置上进程将自己阻塞起来等待信号;  当该进程所依赖的进程执行到步调一致以后,  会向操作系统发出信号;  操作系统收到信号以后,  将阻塞进程唤醒执行.

​		以生产者消费者举例,  分析如何使用信号解决同步问题.

```java
//生产者(producer)进程
while(true){
	if(counter == BUFFER_SIZE){
		sleep_on(empty);
	}
	buffer[in] = item;
	in = (in + 1) % BUFFER_SIZE;
	counter++;
	if(counter == 1) {
		wake_up(full)
	}
}
```

```java
//消费者(consumer)进程
while(true) {
		if(counter == 0) {
			sleep_on(full);
		}
		item = buffer[out];
		out = (out + 1) %BUFFER_SIZE;
    counter--;
    if(counter==BUFFER_SIZE - 1) {
    	wake_up(empty)
    }
}	
```

​		在生产者消费者模型中,  由于缓冲区大小是有限的,  所以当生产者生产的东西占满缓冲区时,  需要停下来,  等待消费者消费东西,  释放出空闲的缓冲区,  然后再进行生产;  同样,  当消费者消费完缓冲区中的东西时,  需要停下来,  等待生产者继续放入东西,  然后再进行消费.

​		基于如上同步解决方案,  定义了两个信号: empty和full,  其中empty表示“空闲缓存区个数”,  消费者进程用掉了一个内容单元时,  即产生一个空闲缓存区时,  会向生产者进程发送一个empty信号,    名字empty表达的就是“空闲”的含义.  类似地.  full信号表达的含义是“缓存区中有内容单元”,  所以生产者产生一个空闲单元(item),  并在产生内容以后向消费者进程发出full信号.

#### 将信号扩展为信号量

​		基于上面的解决方案,  有这么一种进程调度的情况:  在缓存区满时进来两个生产者进程,  然后又进来一个消费者进程,  这时会怎么样?  缓存区满时,  两个生产者进程P1P2由于counter==BUFFER_SIZE条件成立,  P1P2都会进入阻塞态等待信号empty; 然后消费者进程有且只有一个C1进程进来,  在C1循环执行一次消费一个内容单元(item)时,  判断条件counter == BUFFER_SIZE-1, C1会唤醒一个生产者进程; C1进程在循环执行第二次,  由于此时判断条件counter == BUFFER_SIZE-2不成立,  另外一个消费者进程就无法被唤醒,  仍然处于阻塞态等待信号empty.   按照语义,  现在有了一个空闲单元,  却有一个生产者进程被阻塞需要等待空闲单元的到来,  显然不正确,  那么问题到底出现在那里呢?

​		总的来说,  用counter变量控制生产者进程与消费者进程的停与走,  用信号记录进程停/走的位置,  时无法应对多变的调度情况了,  这时因为counter表达出来的语义不够.  counter的语义时正确的,  因为counter记录了缓存区中item的个数,  因此无论只有P1等待还有P1和P2两个进程等待,  两种情况下缓存区汇总的item个数都是BUFFER_SIZE.  因此counter的语义并没有出错,  而是counter的语义信息太少,  无法充分反映阻塞在empty信号上的进程个数信息,  从而导致上述应该将P2唤醒还是却没有唤醒的错误情况.

​		根据上面的分析,  解决问题的办法显然是要引入新的变量来记录更多的信息,  比如要记录等待在信号empty上的进程个数这样的信息,  同时,  也可以用这个变量来控制进程的阻塞与唤醒.  由于记录了在某个信号上等待的进程个数,  信号就对应了一个变量,  这就是从信号到信号量的扩展.  因此,  信号量就是在信号上关联的一个整数,  可以根据这个整数来决定进程的阻塞和唤醒.

​		根据前面的例子,  使用信号量来分析.  当有一个生产者进程发现没有空闲单元时进行阻塞,  empty=-1,  表示缺少一个空闲单元;  当另外一个生产者进程做同样的操作并被阻塞时,  empty=-2,  表示缺少两个空闲单元,  并且有两个生产者等待资源并且被阻塞;  当有一个消费者进程执行一次时,  会释放出一个空闲单元,  这时会唤醒一个生产者进程, 此时empty=-1;  当这个消费者进程再执行一次时,  会唤醒另外一个生产者进程,  empty=0,  此时表示没有生产者进程被阻塞,  同时也没有空闲单元;  同样的,  如果有一个空闲单元时,  使用empty=1表示,  生产者不用等待.

​		因此,  现在信号量empty的数值就能表达更多的含义,  并且能准确控制进程的走与停.

- 对empty而言,  当它为正数或零时,  就表示现在和该信号对应的资源还有empty个;  如果是负数,  就表示现在欠着|empty|个资源,  即现在有|empty|个进程再等待该信号量对应的资源.
- 对生产者进程而言, 当它看到empty为正数时,  表示还有资源,  生产者不用阻塞,  继续执行;  当empty为零或者负数时,  表示已经没有资源了,  生产者阻塞,  等待唤醒;
- 对消费者而言,  当它看到empty为零或正数时,  表示没有进程阻塞在empty上,  不用唤醒;  当empty为负数时,  表示有生产者进程阻塞在empty上,  调用wake_up唤醒一个生产者进程

​            给出信号量的准确定义:

1. 信号量就是一个整形变亮,  用来记录和进程同步有关的重要信息;
2. 能让进程阻塞睡眠在这个信号量上
3. 需要同步的进程通过操作信号量来实现进程的阻塞和唤醒,  即进程间的同步.

​         因此,  信号量就是一个数据对象以及操作这个数据对象的两个操作,  其中数据对象时信号量数值以及相应的阻塞进程队列,  而在这个数据对象上的两个操作就是对信号量数据的加1和减1,  并根据加减后的信号量数据决定的睡眠和唤醒.

```c
// 信号量数据结构及其操作的伪代码实现	
struct semaphore
{
  int value; //信号量数值,  用来记录资源个数或进程个数
  PCB *queue; //等待在该信号上的进程队列
}

//对信号量进行减1的操作,  根据减去1以后的信号量数值来决定进程是否睡眠等待
P(semaphore s) 
{
  s.value--;
  if(s.value<0)
    	sleep.on(s.queue)
}

//对信号量进行加1的操作, 根据加1以后的信号量数值决定是否要唤醒睡眠在该信号量上的进程
V(semaphore s) 
{
  s.value++;
  if(s.vlaue <=0)
    	wake.up(s.queue)
}
```

#### 生产者-消费者同步问题的信号量解法

```c
semaphore full = 0;
semaphore empty = BUFFER_SIZE:
// 由于是共享缓存区, 所以使用mutex阻止当某个进程在进行修改时其他进程执行同一块代码; 当mutex是0时, 其他进程只能被阻塞, 等待被唤醒
semaphore mutex = 1;

//生产者进程
while(true) 
{
  P(empty);
  P(muter);
  buffer[in] = item;
  in = (in+1) % BUFFER_SIZE;
  V(muter);
  V(full);
}

//消费者进程
while(true)
{
  P(full);
  P(muter);
  item = buffer[out]
  out = (out + 1)%BUFFER_SIZE;
  V(muter);
  V(empry);
}
```

## 