## 操作系统启动过程

这里看的是Linux0.11的代码。

### 打开电源之后，计算机执行的是什么

以86PC为例：

1. 86PC刚开机时处于实模式
2. 开始时，CS=FFFFH；IP=0H，这两个寄存器的值是由硬件设计者来决定
3. 寻址FFFF0H，这里是ROM BIOS映射区，要执行这里的程序
4. BIOS里的程序会检查RAM，键盘，显示器，软硬磁盘，如果这步过不去，说明硬件坏了
5. 如果检查硬件通过,则利用BIOS将磁盘0磁道0扇区512个字节读入7C00H处，磁盘中这个地方是引导扇区，里面放着引导代码。
6. 设置CS=07C0H；IP=0H, 执行启动扇区中的代码.

#### 磁盘引导扇区

​		磁盘引导扇区是启动设备的第一个扇区，启动设备信息被设置在CMOS中，因此，硬盘的第一个扇区上存放着开启后会执行的第一段我们可以控制的程序。操作系统的故事从这里开始。

​		引导扇区存的代码是汇编写的代码。实用汇编语言来编写,是因为要让开机过程严格遵照要求来执行,用C语言写程序虽然简单很多,但C程序经过编译以后有很多细节是不能由我们控制的.

### 第一阶段, 执行bootsect.s文件

​		bootsect.s文件是读入的第一个文件, 它的主要作用是将运行操作系统所需要的文件读入内存.

​		bootsect.s具体功能如下:

1. 将原本在内存中0x7C000出的bootsect.s代码启动到0x90000处, 这样做是为之后加载操作系统代码做准备.
2. 将磁盘上从第二到第五的这四个扇区构成的setup模块读到了内存的0x90200处.
3. 在显示器上输出操作系统logo
4. 从磁盘的第六个扇区开始读入长度为SYSSIZE的操作系统system模块,并将其存放到内存0x10000处.

​       从代码中可以得知,  想要让bootsect.s正常工作, 必须得按照一定的顺序在磁盘中存放bootsect.s setup.s以及system模块, 存放顺序是第一个扇区必须放置bootsect.s编译后的结果, 第二到第五的四个扇区必须放置setup.s编译后的结果,  第六个扇区开始放置编译后的system模块.

### 第二阶段, 执行setup.s文件

​		setup.s文件是在做一些初始化工作. 主要有下面几部分工作.

1. 初始化必备的一些基本参数, 比如需要知道内存有多大, 磁盘有多大.
2. 开启保护模式, 从16位模式切换到32位模式.
3. 将在内存中的system模块拖拽到0x0地址, 也就是将内存地址0x10000 ~ 0x90000间的全部内容移动到地址0x00000~0x80000处.

​       开启保护模式时, 需要将CR0寄存器到最后一位置成1,  这样内存寻址方式会采用另外一套电路, 保护模式电路.  保护模式下的寻址方式发生了变化, 不再是段地址向左偏移4位再加偏移地址,  而是使用段寄存器作为索引在一个GDT表中找到32位基址,  再和32位的偏移地址相加,  形成的最终的地址放到地址总线上去选定内存.

​		在将system模块移动位置之后, 由于BIOS中断向量表存放在0地址处,  BIOS中断被覆盖了,  在后面需要从新设置中断.

### 第三阶段, 执行head.s文件

​		在system模块中,  分为两部分,  一部分是head.s,  另外一部分是system文件代码,  这两部分是通过编译是放在一起.  head.s文件是放在前面的,   所以起名为head,  另外这部分工作没有放在system模块,  一个原因是这部分的代码与system的代码功能上有所区别,   但是又紧密相连.

​		head.s要执行的步骤:

1. 设置中断表,  在前面的工作中,  将操作系统复制到了内存开始的地方,  已经将BIOS的中断向量表覆盖了; 另外,  接管中断是操作系统必须要做的事情,  因为不同的操作系统遇到同一中断时所实施的操作是不一样的.
2. 设置GDT表,  虽然在setup中建立了GDT表,  但那是为了执行`jmpi 0,8`时临时建立的,  现在进入了sysetm模块,  需要重新建立.
3. 设置页表, 进入32位保护模式以后,  寻址更加复杂, 使用`GDT[CS] + IP`获得的地址还需要在页表中索引一次才能得到真正的物理地址并输出到地址总线上.  启动分页机制需要将CR0寄存器的第一位设为1.

​       由于system被移动到了内存开始的地方,  所以在寻址时,  直接使用偏移地址和完成地址映射过程输出到物理内存上的物理地址是一样的,  但是这样做可以省去很多麻烦.

### 第四阶段, 操作系统启动

​		在这一阶段是通过head.s文件中调用C语言函数main()来实现的,  这个函数的主要功能是初始化各种管理软硬件资源的数据结构,  可以调用各种初始化函数来完成相应的初始化工作,  比如调用mem_init()用来初始化内存,   调用hd_init()来初始化硬盘.