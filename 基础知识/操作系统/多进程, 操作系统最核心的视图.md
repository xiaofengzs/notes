## 多进程, 操作系统最核心的视图

​		操作系统是一个管理计算机硬件的软件系统,  这里开始讲如何管理CPU、

### CPU的管理与进程概念的引出

#### 如何使用CPU

​		CPU的工作原理就是不断的取指、执行,  再取指、执行.  因此让CPU运转起来其实很简单:  将一段程序放在内存中,  然后将PC指针设置为这段程序的起始地址,  接下来CPU就不断的取指执行,  CPU开始工作了.

​		指令是在内存中,  指令是计算机将在磁盘上的程序加载到内存中而来,  过程如下:

- 第一步,  在内存中分割出一些区域
- 第二步,  调用磁盘驱动和文件系统将一个程序的可执行程序读入分配好的内存中
- 第三步,  将这段分配好的内存区域的首地址即存储程序第一条指令的内存地址赋给CS:EIP

​       接下来就是等着CPU不断地工作,  直到这段程序执行完以后,  然后再重复做上面的事,  让CPU执行下个程序,  这样CPU就不停地运转起来了.

#### 问题的引出与并发

​		在CPU执行的指令中,  有一些指令是I/O指令,  执行一条I/O指令的时间可以执行一百万条计算指令,  这种差异是非常巨大的.  如果在没有任何机制的情况下顺序执行指令的过程中遇到了I/O指令,  那么CPU将会等待一段时间,  直到I/O结果返回才会继续,  在这种情况下,  CPU有等待时间,  没有被充分利用.

​		 怎么样才能充分利用CPU?  不要让CPU长时间处于空间状态,  也就是不让CPU等待.  当CPU执行I/O执行并处于等待状态时,  利用这段等待时间去干一些别的事情,  这样利用率将会提高,  也就是CPU处于空闲状态时,  切换到其他程序上去执行,  这种执行的方式就叫并发.

#### 进程与程序

​		将PC设置为一段程序的初始地址以后,  CPU就开始工作了;  而采用了并发思想以后,  PC会在多段程序之间来回切换,  CPU就可以高效的工作了.

​		操作系统高效管理CPU的具体实现为"要在多段程序之间来回切换",  要实现这种切换只PC指针式不够的.   在CPU运算的过程中,  会使用到各种寄存器,  如果在切换时没有将寄存器中的数据保存下来,  那么在后面切换回来时,  寄存器中的数据已经被其他程序修改,  CPU将会在错误的数据上进行运算,  得到的计算结果也是不正确的.  显然,  在切换运行中程序时需要将寄存器中的数据保存下来,  也就是需要保存此时的运行环境.  这样就会产生一种结构:  一个程序要附带着一个数据结构,  这样才能保证其正确执行,  才能实现多个执行着的程序之间来回切换,  这个数据结构保存了这个程序当前执行的位置、执行现场等重要信息.

​		由于这种程序 + 记录当前执行情况的结构是并发造成的一个必然结果,  也就是在实现CPU高效管理时必然要出现的一个结构,  因此要实现并发、实现CPU的高效管理,  就有必要实现这种结构.  当然,  在实现这种结构之前,  我们有必要针对这一结构定义一个概念,  着就是操作系统中最著名的概念——进程.  进程用来描述一个程序极其执行过程中的信息,  即描述一个执行中的程序,  所以才将其命名为进程,  即进行中的程序.

​		对比程序和进程的概念,  程序时静态的指令、数据等,  而进程是执行起来的程序.

​		现在将进程的概念再具体化一些,  进程描述的是“程序以及反映程序执行信息的数据结构的综合”,  因此这个数据结构就称为认识进程的一个关键.  人们也给这个数据结构定义了一个基本概念,  即进程控制块(process control block, PCB).

#### CPU管理和多进程视图

​		有了进程概念之后,  可以应用进程概念来对CPU管理重新做描述: CPU的工作原理就是取指执行,  即执行程序,  而执行起来的程序是进程,  因此使用CPU和启动进程实际上等价的.  如果只有一个进程,  遇到I/O操作时,  CPU只能等待I/O完成,  造成CPU工作效率低下.  为了提高CPU效率,  操作系统中应启动多个进程,  并能在多个进程之间合理切换.  现在CPU管理的最终结构可以概括为操作系统启动多个进程,  并能在多个进程之间调度/切换,  从而实现CPU高效管理.

​		多进程时图是操作系统的核心视图,  操作系统在从开机启动到最后关机的全部运行过程中,  都要围绕这个多进程时图工作.  具体来说,  在系统启动的最后,  进程0被创建出来;  然后通过fork()系统调用创建出1号进程,  并让1号进程执行shell程序; 接下来shell会调用fork()来创建一个进程,  去执行用户输入命令对应的程序;  用户程序可以通过fork()创建出来的新进程来执行对应的任务.

​		一个进程执行完毕以后可以调用exit()来推出自己, 但shell不会调用exit()推出自己,  除非关机. 因此shell进程会一直执行,  不断创建新的进程,  并用这些新进程完成各种各样的任务.  在操作系统最终关机时,  会将系统中所有进程杀死.

#### 如何切换正在执行的程序

​		在多道程序系统中,   需要切换正在执行的程序.  如何切换?  在为PC赋值之后,  PC指向了一段指令序列,  CPU就可以运行了.  切换正在执行的程序需要做的是,  让PC执行另外一段指令序列,  这样CPU就可以执行另外的程序了.  只切换PC的指向并不够,  因为此时寄存器中的值还是上个执行的程序的值,  所以需要使用当前执行程序的值进行覆盖,  并且在切换出当前正在执行的程序时,  需要将运行现场保存起来,  这样才能在下次切换回来时,  恢复现场.  总结一下就是切换出去时,  需要记录下来当时要切出去时的样子,  这样才能切回来.

### 多进程引起的基本问题

#### 多个进程的组织和进程状态

​		PCB描述了一个进程执行状态,  操作系统管理进程的关键就是管理进程对应的PCB数据结构,  那么组织多个进程就是用合适的数据结构来管理这些PCB.  实际上,  进程之间的关系并不复杂,  通常都是并列地“排在”各自的队列中等待CPU空闲、等待磁盘读写完成.  因此这些PCB之间的关系就是一种线性关系,  简单而高效的一种方式就是将这些PCB组织成队列.

​		在管理进程时需要区分进程到底位于那个队列,  因为等待CPU的进程和等待磁盘读写完成的进程是不一样的:  等待CPU的那些进程在当前进程让出CPU的时候,  都可以获得CPU向前执行;  而对于等待磁盘读写完成的进程,  即使当前进程让出了CPU,  这些进程也不能立即执行,  因为还有等待条件没有满足.

​		可以根据进程状态概念来分类描述操作系统中的进程.  操作系统中的进程状态主要包括:  运行态——当前占有CPU、正在执行的进程状态;  就绪态——一个进程具备了所有可以执行的条件,  只要获得CPU就能开始执行;  阻塞态——也称睡眠态或等待态,  是指一个进程因为缺少某些条件,  即使分配了CPU也无法执行的状态.  有了这三个状态,  就相应地产生了三个PCB队列.  在一个系统中,  会有多个进程处于不同的状态,  并且会处于不同类别的队列中.  在某一时刻下多个进程在操作系统中的样子,  即某一时刻的快照.  这是以纵向的角度来看进程,  即以时间轴给出的进程组织.

​		还可以以横向描述多进程的演化,  即根据时间轴.  一个进程是有多种状态的,  那么几种状态是可以互相转换的:

进程刚创建出来时是新建态,  然后会变成就绪态,  就绪态的进程被调度后会成为运行态,  运行态的进程被剥夺CPU后会变成就绪态,  要是运行态的进程在等待某事件时会变成阻塞态,  某事件发生时阻塞态的进程会变成就绪态,  如果运行态的程序执行完毕后会变成推出态.

#### 多个进程的切换和调度

​		多进程时图的核心是多个进程之间的来回切换,  这也是并发的基本含义.  什么时候切换、具体如何切换,  这两个问题是操作系统实现多进程需要回答的基本问题.

​	 	什么时候需要切换?  当一个进程正在执行,  执行过程中发出来写磁盘的指令,  当前进程由于等待磁盘事件而变成了阻塞态,  CPU被让了出来.  当CPU空闲时需要引起切换.  这些空闲点也被称为调度点,  调度点可以是当前进程在执行过程中产生的,  如exit(),  也可以是操作系统硬性加入的,  如给每个进程分配一个时间片,  当前进程的时间片用完时,  操作系统会硬性加入一个调度点进行切换.

​		如何实现? 操作系统调用函数schedule()实现切换.  这个函数的实现原理很简单.  即从就绪队列中选出下一个进程的PCB,  即pNEew,  然后用PCB结构pNew中存放的执行现场去替换CPU中的寄存器.  为了将来能切换回到当前进程,  切换之前还应该将CPU李敏啊的“当前进程执行现场”保存在当前进程的PCB结构中.

​		另外, 如何选择pNew也是一个需要精心设计的蒜放,  虽然每次选择就绪队列首部的进程作为下一个进程是一个绝对公平的方案,  但是有些进程应该优先执行,  比如工作在前台的网页浏览器进程.  如果工作在前台的inching总是有限执行,  那么工作在后台的进程,  如编译整个操作系统的make进程就可能总是得不到执行,  这也不合适.  如何合理折中系统里多种多样的进程是一项重要又困难的任务.

#### 进程间的影响分离

​		多个进程同时存在内存中交替执行可以提高CPU使用效率,  但是也会产生一些问题,  因为同时在内存中的多个进程会互相印象.  例如,  进程1执行了一个修改内存地址100的指令,  而内存地址100处存放的却是进程2的苏剧,  显然会导致进程2发生错误.  进程1为什么会操作到进程2使用到的内存地址,  可能是设计缺陷,  也有可能是病毒,  并且进程1和进程2都属于用户态内存区域,  所有进程的CPL = DPL = 3,  所以进程1对地址100的访问完全合法,  这显然不合法.

​		解决这个问题的办法是地址隔离.  每个进程操作的地址不直接是真实的物理内存地址,  而是操作对应的映射表,    通过映射表访问实际的物理内存地址,  此时两个进程的地址空间也能被完全分离开来,  每个进程可以随意读写进程任何地址,  不用担心会因误操作影响其他进程,  也不用担心其他进程会影响自己.  例如,  进程1中地址100在映射表中对应的实际物理内存地址为2100,  进程2中地址100在映射表中对应的实际物理内存地址为1100,  操作系统为两个进程分配内存时本来就会分配不用的内存空间,  这样即使进程1操作地址为100的内存空间也不会影响到进程2.

#### 进程间的通信与合作

​		多个进程同时存放在内存中,  需要隔离之间的影响,  但有时也需要相互合作.  例如,  一个浏览器启动了两个进程,  其中一个负责和服务器建立连接并下载数据,  另一个负责将数据显示出来.  对于浏览器而言,  两个进程相比一个进程的好处是不用等数据全部下载完,  用户就能在浏览器上看到部分信息.

​		这就产生了进程间的通信和合作的问题,  最基本的进程间合作模型是一个进程要往一个缓存区写数据,  而另外一个进程要从缓存区里读数据.  此时就需要一个合适的进程间通信机制与合作机制.