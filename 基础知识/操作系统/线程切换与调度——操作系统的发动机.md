## 线程切换与调度——操作系统的发动机

​		多进程并发结构,  即讲多个进程同时存放在内存中启动执行,  然后在这些进程之间来回切换、交替执行,  这样的结构可以让CPU的工作效率大幅提升,  也提高了整个计算机硬件的工作效率.  因此,  多进程来回切换、交替执行是操作系统的核心工作,  一言以蔽之,  CPU切换是整个操作系统的发动机.

​		这一部分引出线程的概念,  并以线程为单位对CPU切换进程详细论述,  这是因为线程切换是进程切换的核心内容. 进程切换由资源切换和指令流切换两部分组成,  其中资源切换是将分配给进程的非CPU以外的资源进行切换,  如对当前地址空间进程切换;  而指令流切换就是CPU却换,  也就是线程切换.

### 线程与进程

#### 线程是什么

​		并发是CPU高效工作的基础,  而并发的基本含义就是多段程序交替执行.  既然是多段程序之间交替执行,  那这种交替就不一定总存在于两段“很远”的代码之间,  如浏览器程序和编译器程序之间的交替.  即使是在同一个可执行文件内,  两个函数之间也可以交替,  如在同一个浏览器内部有两个函数GetData()和Show(),  这两个函数可以交替执行,  这样的交替执行就产生了线程.

#### 一个多线程实例

​		现在通过一个例子对线程建立更直观的认识.  当我们用浏览器打开斯坦福大学的主页,  可以看到在浏览器上首先出现的是网页中的文字部分,  过了一段时间一些小的图片就被显示出来,  而那些更大的图片和动画则需要通过一段时间才能渲染出来.  这样做的好处是用户很快就能看到一些文字信息,  然后再是图片信息,  而不是等待较长一段时间以后看到网页的全部信息,  显然这种逐步显示的方式其用户交互性友好的很多.

​		在这个浏览器过程中,  启动了四个线程,  分别是获取数据、显示文本的线程、解压图片的线程和渲染图片的线程.  首先获取数据的线程被调度开始工作,  将网页的总体布局以及页面中的文本信息下载下来;  然后切换到显示文本的线程将网页的基本结构和其中的文本信息显示在浏览器中; 接下来再通过网页布局信息下载其中的图形对象标签;  下载一些图片对象以后在切换到解压图片的线程执行,  待解码完成以后切换到渲染图片的线程执行,  此时图片就会被逐个显示出来.

#### 线程与进程

|                    |      线程      | 进程            | 详细描述                                                 |
| ------------------ | :------------: | --------------- | -------------------------------------------------------- |
| 能否并发           |       能       | 能              | 都能够做到程序的交替执行                                 |
| 切换内容           |     指令流     | 指令流+其他资源 | 进程切换时资源需要跟着一起切换                           |
| 切换代码           |       小       | 大              | 线程切换时一些资源不需要切换, 如内存映射表               |
| 创建速度(资源消耗) |     快(小)     | 慢(大)          | 创建线程时直接使用进程共有的资源                         |
| 相互影响           |  操作统一内存  | 完全分离        | 多个线程使用相同的地址空间, 即使用相同的映射表           |
| 安全性             |       小       | 大              | 一个线程中的代码可以访问统一进程下其他线程的任意内存位置 |
| 隶属关系           | 隶属于一个进程 | 隶属于操作系统  | 线程不能脱离进程而存在,  即没有进程就不会创建线程        |

### 用户级线程的切换与创建

​		线程是在一个地址空间下启动并交替执行多个程序.  线程分为用户级线程和内核级线程.  用户级线程由用户程序自己管理,  对操作系统透明,  操作系统不知道这些线程的存在;  内核级线程是由操作系统来管理的,

#### 用户线程之间的切换

​		用户线程切换过程:

- 用户级线程的切换就是在切换位置上调用Yield()函数
- Yield()函数完成的基本工作是找到下一个线程TCB,  然后根据当前线程的TCB和下一个线程的TCB完成用户栈的切换.  具体来说,  就是将寄存器ESP中的值保存在当前线程TCB中,  然后从下一个线程的TCB中取出保存的esp值赋给ESP寄存器.
- 在切换到新栈以后用Yield()函数中的“}”将PC指针切换到下一个线程要执行的指令处
- 当然还需要在线程切换时保存和恢复一些执行现场,  无非就是保存一些通用寄存器,  这些寄存器的值也要放在线程各自的栈中保存,  在栈切换完成以后弹栈恢复下一个线程的执行现场.

#### 用户级线程的创建

​	和进程一样,  线程也是一段执行起来的城西,  所以创建线程的目的就是要让一段程序执行起来.  想要执行起来,  那么就需要把一段程序做成可以让CPU切入执行的样子,  并且CPU切入点是这段程序的收地址,  显然这段程序就可以执行了.

​	//todo 创建细节没有搞懂.

### 内核级线程的切换和创建

#### 内核级线程的引出

​		一个用户级线程在执行过程中可能会进入内核态,   例如下载数据要通过网卡,  网卡是由操作系统负责驱动、管理的,  所以下载数据要借助系统调用进入操作系统内核才能完成.  用户级线程进入操作系统内核以后,  很可能要发生CPU切换,  例如要等待网络连接建立成功,  在这个等待过程中,   CPU完全可以切换出去执行其他程序来实现CPU的高效利用.

​		此时可能会出现的情况是,  一个用户级线程被阻塞,  即使在这个进程中有其他用户级线程存在,  操作系统也感知不到,  无法切换到统同一进程中的其他用户级线程执行,  此时该进程中所有的用户级线程阻塞, CPU就会切换到其他进程中去执行.  这就限制了用户级线程的并发成都,  从而限制了由并发性带来的计算机硬件工作效率的提升.

​		和用户级线程对应的是内核级线程概念.  用户级线程是我安全在用户态内存中创建的一个指令执行序列,  即用户级线程的TCB、栈等内容都是创建在用户态中的,   操作系统完全不知道.  现在,  内核级线程就是要让内核态内存和用户态内存合作创建一个指令执行序列,  内核级线程的TCB等信息是创建在操作系统内核中的,  操作系统通过这些数据结构可以感知和操作操作内核级线程.

​		举个例子,  在双核操作系统中,  如果没有内核级线程,  那么即使有两个进程的存在,  假设其中一个进程正在使用共享存储管理部件(memory management unit, MMU)以及一些缓存,  多核通常要共享这些部件,  所以在这种情况下, 可能出现只有一个核被使用的情况.  假如在每个进程中都有多个内核级线程的存在,  在这种情况下,  内核级线程是可以共享MMU以及缓存的,  所以多核可以同时执行.  内核级线程非常适合于多核处理器结构,  而多内核处理器是现代处理器设计中的一种主流设计,  目前绝大多数现代操作系统都支持内核级线程.

​		内核级线程有其优点:  可以提高并发性,  可以有效支持多核处理器等;  进程也有其优点:  以进程为单位来分配计算机资源,  方便管理,  进程之间互相分离,  安全性高、可靠性好等;  当然用户级线程也有其优点:  用户在用户程序中随意创建,  创建代价小、灵活性大,  同时具有一定的并发性等.  因此在操作系统中,  这个概念往往都是同时存在.

​	用户级线程、内核级线程、进程这三者的内在关系概括如下.

 	1.	引出进程的目标是为了管理CPU,  即通过执行程序来使用CPU.  进程、内核级线程、用户级线程都是执行一个指令序列,  没有本质区别,  所以这三者都属于CPU管理范畴.
 	2.	要执行一个指令学咧,  除了通过分配栈、创建数据结构记录执行位置等以外,  还要分配内存等资源,  这就是进程的概念.
 	3.	将进程中的资源和执行序列分离以后引出来线程概念,  进程必须在操作系统内核中创建,  这是因为进程创建要涉及计算机硬件资源的分配.  因此进程中的那个执行序列实际上就是一个内核级线程.
 	4.	内核级线程是操作系统在一套进程资源下创建的、可以并发的多个执行序列,   操作为每个这样的执行序列创建了相应的数据结构来实现对着先内核级线程控制,  如切换、调度等.
 	5.	同样地,  上层应用也可以创建并交替执行多个指令执行序列,  因为执行程序所需要的资源已经在创建进程时分配好了.  此时启动多个执行序列所需要的TCB和用户栈等信息完全可以由应用程序自己编写实现,  由应用程序负责多个进程序列,  对操作系统完全透明.

#### 内核级线程之间的切换

​		用户级线程的切换,  主要分为三部分: TCB切换,  根据TCB中存储的栈指针完成用户栈切换,  根据用户栈中压入函数返回地址完成PC指针切换.

​		内核级线程也要完成这三件事情,  区别在于,  内核级线程的TCB存储在操作系统内核中,  因此完成TCB的切换时在操作系统内核中.  用户级线程是通过用户函数Yield()来执行,  而内核级线程必须先使用中断进入内核再切换.  因此中断会导致从用户态到内核态的切换.

​		另外一个区别在于,  先得从用户栈切换到对应的内核栈,  然后内核栈完成三件事情.  因此和用户级线程相比,  内核级线程的切换需要同时切换用户栈和内核栈.

​		综上所述,  用户级线程切换的核心是根据存放在用户程序中的TCB找到用户栈,  通过用户栈切换完成用户级线程的切换,  整个切换过程条用Yield()函数引发.  内核级线程切换的核心是首先进入操作系统内核并在内核中找到线程TCB,  进而根据TCB找到线程的内核栈,  通过内核栈切换完成内核线程切换,  整个切换过程由中断引发.

​		使用户栈切换到内核栈的中断的任务如下:

1. 实现函数跳转.  使用中断来实现函数跳转,  所以要在指令int执行的那一刻启动内核栈,  这样一进入操作系统内核就可以进行函数调用了.
2. 切换到内核栈.  内核栈和用户栈不是同一个栈,  内核栈应该是一段具有特权级的内存区域,  其原因是为了保护内核.
3. 记录返回地址CS:EIP.  既然要进行函数跳转,  那么就需要使用栈保存返回地址CS:EIP.
4. 记录SS:ESP.  用户栈和内核栈不是同一个栈,  想要返回用户栈就得记录用户栈的地址SS:ESP.

​       内核级线程切换需要完成三个工作:  切换TCB、切换栈和切换PC指针,  这些切换动作分散在中断入口、中断处理、线程调度、上下文切换以及中断返回等多个地方.  这五个阶段具体如下:

- 第一个阶段,  中断进入.  使用int指令或者其他硬件中断的中断处理入口,  核心工作是要记录当前程序在用户态执行时的信息,  如当前使用的用户栈、当前程序执行位置、当前执行的现场等.  其中用户栈地址SS:ESP和PC指针信息CS:EIP已经由中断处理硬件自动压入当前线程对应的内核栈中来,  只有当前的执行现场还没有保存.  所以在进入中段处理程序的开始处需要编写代码保护用户态程序当前执行现场.
- 第二个阶段,  调用schedule,  引起TCB切换.  在中断处理程序汇总,  如果发现当前线程启动了磁盘读写等动能,  即发现当前线程应该让出CPU使,  系统内核就会调用schedule()函数来完成TCB的切换.
- 第三个阶段,  内核栈的切换.  将当前的ESP寄存器存放在current指向的TCB中,  再从next指向的TCB中取出esp字段赋值给ESP寄存器.  由于现在执行在内核态,  所以当前寄存器ESP指向的就是当前线程的内核栈,  二放在TCB中的ESP也是线程的内核栈地址.
- 第四个阶段,  中断返回,  为用户栈切换做准备.  要将存放在下一个线程的内核栈中的用户态程序执行现场恢复出来,  这个现场是这个线程在切换出去时由中断入口程序保存的.
- 第五个阶段,  用户栈切换.  切换用户程序PC指针以及相应的用户栈,  即需要将CS:EIP寄存器设置为当前用户程序执行地址,  将SS:ESP寄存器设置为当前用户栈地址即可,  而这两个信息现在就在下一个线程的内核栈中,  只要执行iret指令就可以完成这个切换了.

#### 内核级线程的创建

​		在了解内核级线程切换过程之后,  内核级线程创建问题也就迎刃而解了:  就是将一个线程初始化成能切换进入,  且切换进去会从其入口函数开始执行的样子.

​		创建内核级线程有以下过程:

- 创建一个TCB,  主要存放内核栈的esp指针.
- 分配一个内核栈,  主要存放用户态程序的PC指针、用户栈地址以及执行现场.
- 分配用户栈,  主要存放进入用户态函数时用到的参数等内容.